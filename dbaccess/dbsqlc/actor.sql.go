// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: actor.sql

package dbsqlc

import (
	"context"
)

const actorDelete = `-- name: ActorDelete :one
WITH check_actor AS (
    SELECT EXISTS (SELECT 1 FROM actors WHERE actors.id = $1) AS actor_exists
),
check_config AS (
    SELECT EXISTS (SELECT 1 FROM configs WHERE configs.actor_id = $1) AS config_exists
),
delete_actor AS (
    DELETE FROM actors
    WHERE actors.id = $1
    AND EXISTS (SELECT 1 FROM check_actor WHERE actor_exists = true)
    AND NOT EXISTS (SELECT 1 FROM check_config WHERE config_exists = true)
    RETURNING id, name, queue_id, created_at, metadata, updated_at, enabled, deployable, configurable, role
)
SELECT
    CASE
        WHEN NOT EXISTS (SELECT 1 FROM check_actor WHERE actor_exists = true) THEN 'NOTFOUND'
        WHEN EXISTS (SELECT 1 FROM check_config WHERE config_exists = true) THEN 'REFERENCED'
        WHEN EXISTS (SELECT 1 FROM delete_actor) THEN 'DONE'
        ELSE 'ERROR'
    END AS result
`

func (q *Queries) ActorDelete(ctx context.Context, db DBTX, id int64) (string, error) {
	row := db.QueryRow(ctx, actorDelete, id)
	var result string
	err := row.Scan(&result)
	return result, err
}

const actorFindById = `-- name: ActorFindById :one
WITH actor_token_count AS (
  SELECT actor_id, COUNT(*) AS token_count
  FROM api_tokens
  WHERE actor_id = $1
  GROUP BY actor_id
)
SELECT
  actors.id,
  actors.name,
  actors.queue_id,
  actors.role,
  actors.enabled,
  actors.deployable,
  actors.configurable,
  actors.created_at,
  COALESCE(atc.token_count, 0) AS token_count,
  CASE WHEN atc.token_count IS NULL OR atc.token_count = 0 THEN true ELSE false END AS renameable
FROM actors
LEFT JOIN actor_token_count atc ON actors.id = atc.actor_id
WHERE actors.id = $1
`

type ActorFindByIdRow struct {
	ID           int64
	Name         string
	QueueID      int64
	Role         ActorRole
	Enabled      bool
	Deployable   bool
	Configurable bool
	CreatedAt    int64
	TokenCount   int64
	Renameable   bool
}

func (q *Queries) ActorFindById(ctx context.Context, db DBTX, id int64) (*ActorFindByIdRow, error) {
	row := db.QueryRow(ctx, actorFindById, id)
	var i ActorFindByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.QueueID,
		&i.Role,
		&i.Enabled,
		&i.Deployable,
		&i.Configurable,
		&i.CreatedAt,
		&i.TokenCount,
		&i.Renameable,
	)
	return &i, err
}

const actorInsert = `-- name: ActorInsert :one
INSERT INTO actors(
    name,
    queue_id,
    role,
    enabled,
    deployable,
    configurable,
    metadata
) VALUES (
    $1::text,
    $2::bigint,
    $3::actor_role,
    $4::boolean,
    $5::boolean,
    $6::boolean,
    coalesce($7::jsonb, '{}')
) RETURNING id, name, queue_id, created_at, metadata, updated_at, enabled, deployable, configurable, role
`

type ActorInsertParams struct {
	Name         string
	QueueID      int64
	Role         ActorRole
	Enabled      bool
	Deployable   bool
	Configurable bool
	Metadata     []byte
}

func (q *Queries) ActorInsert(ctx context.Context, db DBTX, arg *ActorInsertParams) (*Actor, error) {
	row := db.QueryRow(ctx, actorInsert,
		arg.Name,
		arg.QueueID,
		arg.Role,
		arg.Enabled,
		arg.Deployable,
		arg.Configurable,
		arg.Metadata,
	)
	var i Actor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.QueueID,
		&i.CreatedAt,
		&i.Metadata,
		&i.UpdatedAt,
		&i.Enabled,
		&i.Deployable,
		&i.Configurable,
		&i.Role,
	)
	return &i, err
}

const actorListPagenated = `-- name: ActorListPagenated :many
WITH actor_token_count AS (
  SELECT actor_id, COUNT(*) AS token_count
  FROM api_tokens
  GROUP BY actor_id
)
SELECT
  actors.id,
  actors.name,
  actors.role,
  actors.queue_id,
  actors.enabled,
  actors.deployable,
  actors.configurable,
  actors.created_at,
  COUNT(*) OVER() AS total_count,
  COALESCE(atc.token_count, 0) AS token_count,
  CASE WHEN atc.token_count IS NULL OR atc.token_count = 0 THEN true ELSE false END AS renameable
FROM actors
LEFT JOIN actor_token_count atc ON actors.id = atc.actor_id
ORDER BY actors.name
LIMIT $1::bigint
OFFSET $1::bigint * ($2::bigint - 1)
`

type ActorListPagenatedParams struct {
	PageSize int64
	Page     int64
}

type ActorListPagenatedRow struct {
	ID           int64
	Name         string
	Role         ActorRole
	QueueID      int64
	Enabled      bool
	Deployable   bool
	Configurable bool
	CreatedAt    int64
	TotalCount   int64
	TokenCount   int64
	Renameable   bool
}

func (q *Queries) ActorListPagenated(ctx context.Context, db DBTX, arg *ActorListPagenatedParams) ([]*ActorListPagenatedRow, error) {
	rows, err := db.Query(ctx, actorListPagenated, arg.PageSize, arg.Page)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ActorListPagenatedRow
	for rows.Next() {
		var i ActorListPagenatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Role,
			&i.QueueID,
			&i.Enabled,
			&i.Deployable,
			&i.Configurable,
			&i.CreatedAt,
			&i.TotalCount,
			&i.TokenCount,
			&i.Renameable,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const actorUpdate = `-- name: ActorUpdate :one
UPDATE actors SET
    name = COALESCE($1::text, name),
    role = COALESCE($2::actor_role, role),
    enabled = COALESCE($3::boolean, enabled),
    deployable = COALESCE($4::boolean, deployable),
    configurable = COALESCE($5::boolean, configurable),
    metadata = COALESCE($6::jsonb, metadata)
WHERE id = $7
RETURNING id, name, queue_id, created_at, metadata, updated_at, enabled, deployable, configurable, role
`

type ActorUpdateParams struct {
	Name         *string
	Role         NullActorRole
	Enabled      *bool
	Deployable   *bool
	Configurable *bool
	Metadata     []byte
	ID           int64
}

func (q *Queries) ActorUpdate(ctx context.Context, db DBTX, arg *ActorUpdateParams) (*Actor, error) {
	row := db.QueryRow(ctx, actorUpdate,
		arg.Name,
		arg.Role,
		arg.Enabled,
		arg.Deployable,
		arg.Configurable,
		arg.Metadata,
		arg.ID,
	)
	var i Actor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.QueueID,
		&i.CreatedAt,
		&i.Metadata,
		&i.UpdatedAt,
		&i.Enabled,
		&i.Deployable,
		&i.Configurable,
		&i.Role,
	)
	return &i, err
}
