// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: invocation.sql

package dbsqlc

import (
	"context"
)

const invocationFindById = `-- name: InvocationFindById :one
SELECT id, state, queue_id, attempted_at, created_at, finalized_at, priority, payload, errors, result, metadata, tags, attempted_by
FROM invocations
WHERE id = $1::bigint
`

func (q *Queries) InvocationFindById(ctx context.Context, db DBTX, id int64) (*Invocation, error) {
	row := db.QueryRow(ctx, invocationFindById, id)
	var i Invocation
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.QueueID,
		&i.AttemptedAt,
		&i.CreatedAt,
		&i.FinalizedAt,
		&i.Priority,
		&i.Payload,
		&i.Errors,
		&i.Result,
		&i.Metadata,
		&i.Tags,
		&i.AttemptedBy,
	)
	return &i, err
}

const invocationGetAvailable = `-- name: InvocationGetAvailable :many
WITH locked_invocations AS (
	SELECT
		id, state, queue_id, attempted_at, created_at, finalized_at, priority, payload, errors, result, metadata, tags, attempted_by
	FROM
		invocations
	WHERE
		state = 'available'::invocation_state
		AND queue_id = $2::bigint
	ORDER BY
		priority ASC,
		id ASC
	LIMIT $3::integer
	FOR UPDATE
	SKIP LOCKED
)
UPDATE
	invocations
SET
	state = 'running'::invocation_state,
	attempted_at = EXTRACT(EPOCH FROM NOW()),
	attempted_by = array_append(invocations.attempted_by, $1::bigint)
FROM
	locked_invocations
WHERE
	invocations.id = locked_invocations.id
RETURNING
	invocations.id, invocations.state, invocations.queue_id, invocations.attempted_at, invocations.created_at, invocations.finalized_at, invocations.priority, invocations.payload, invocations.errors, invocations.result, invocations.metadata, invocations.tags, invocations.attempted_by
`

type InvocationGetAvailableParams struct {
	AttemptedBy int64
	QueueID     int64
	Max         int32
}

func (q *Queries) InvocationGetAvailable(ctx context.Context, db DBTX, arg *InvocationGetAvailableParams) ([]*Invocation, error) {
	rows, err := db.Query(ctx, invocationGetAvailable, arg.AttemptedBy, arg.QueueID, arg.Max)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Invocation
	for rows.Next() {
		var i Invocation
		if err := rows.Scan(
			&i.ID,
			&i.State,
			&i.QueueID,
			&i.AttemptedAt,
			&i.CreatedAt,
			&i.FinalizedAt,
			&i.Priority,
			&i.Payload,
			&i.Errors,
			&i.Result,
			&i.Metadata,
			&i.Tags,
			&i.AttemptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const invocationInsert = `-- name: InvocationInsert :one
WITH agent_queue AS (
	SELECT queue_id
	FROM agents
	WHERE name = $8::text
)
INSERT INTO invocations(
	state,
	queue_id,
	created_at,
	finalized_at,
	priority,
	payload,
	metadata,
	tags
)
SELECT
	$1::invocation_state,
	agent_queue.queue_id,
	coalesce($2::bigint, EXTRACT(EPOCH FROM NOW())),
	$3,
	$4::smallint,
	$5::jsonb,
	coalesce($6::jsonb, '{}'),
	coalesce($7::varchar(255)[], '{}')
FROM agent_queue
RETURNING id, queue_id
`

type InvocationInsertParams struct {
	State       InvocationState
	CreatedAt   int64
	FinalizedAt *int64
	Priority    int16
	Payload     []byte
	Metadata    []byte
	Tags        []string
	AgentName   string
}

type InvocationInsertRow struct {
	ID      int64
	QueueID int64
}

func (q *Queries) InvocationInsert(ctx context.Context, db DBTX, arg *InvocationInsertParams) (*InvocationInsertRow, error) {
	row := db.QueryRow(ctx, invocationInsert,
		arg.State,
		arg.CreatedAt,
		arg.FinalizedAt,
		arg.Priority,
		arg.Payload,
		arg.Metadata,
		arg.Tags,
		arg.AgentName,
	)
	var i InvocationInsertRow
	err := row.Scan(&i.ID, &i.QueueID)
	return &i, err
}

const invocationSetCompleteIfRunning = `-- name: InvocationSetCompleteIfRunning :one
WITH invocation_to_update AS (
	SELECT invocations.id
	FROM invocations
	WHERE invocations.id = $1::bigint
		AND invocations.state = 'running'::invocation_state
		AND (
            array_length(attempted_by, 1) > 0
            AND attempted_by[array_length(attempted_by, 1)] = $2::bigint
        )
	FOR UPDATE
),
updated_invocation AS (
	UPDATE invocations
	SET
		finalized_at = $3::bigint,
		result = $4::jsonb,
		state = 'completed'
	FROM invocation_to_update
	WHERE invocations.id = invocation_to_update.id
	RETURNING invocations.id, invocations.state, invocations.queue_id, invocations.attempted_at, invocations.created_at, invocations.finalized_at, invocations.priority, invocations.payload, invocations.errors, invocations.result, invocations.metadata, invocations.tags, invocations.attempted_by
)
SELECT id, state, finalized_at
FROM updated_invocation
`

type InvocationSetCompleteIfRunningParams struct {
	ID          int64
	FinalizerID int64
	FinalizedAt int64
	Result      []byte
}

type InvocationSetCompleteIfRunningRow struct {
	ID          int64
	State       InvocationState
	FinalizedAt *int64
}

func (q *Queries) InvocationSetCompleteIfRunning(ctx context.Context, db DBTX, arg *InvocationSetCompleteIfRunningParams) (*InvocationSetCompleteIfRunningRow, error) {
	row := db.QueryRow(ctx, invocationSetCompleteIfRunning,
		arg.ID,
		arg.FinalizerID,
		arg.FinalizedAt,
		arg.Result,
	)
	var i InvocationSetCompleteIfRunningRow
	err := row.Scan(&i.ID, &i.State, &i.FinalizedAt)
	return &i, err
}

const invocationSetFailureIfRunning = `-- name: InvocationSetFailureIfRunning :one
WITH invocation_to_update AS (
	SELECT invocations.id
	FROM invocations
	WHERE invocations.id = $1::bigint
		AND invocations.state = 'running'::invocation_state
		AND (
            array_length(attempted_by, 1) > 0
            AND attempted_by[array_length(attempted_by, 1)] = $2::bigint
        )
	FOR UPDATE
),
updated_invocation AS (
	UPDATE invocations
	SET
		finalized_at = $3::bigint,
		errors = $4::jsonb,
		state = 'discarded'
	FROM invocation_to_update
	WHERE invocations.id = invocation_to_update.id
	RETURNING invocations.id, invocations.state, invocations.queue_id, invocations.attempted_at, invocations.created_at, invocations.finalized_at, invocations.priority, invocations.payload, invocations.errors, invocations.result, invocations.metadata, invocations.tags, invocations.attempted_by
)
SELECT id, state, finalized_at
FROM updated_invocation
`

type InvocationSetFailureIfRunningParams struct {
	ID          int64
	FinalizerID int64
	FinalizedAt int64
	Errors      []byte
}

type InvocationSetFailureIfRunningRow struct {
	ID          int64
	State       InvocationState
	FinalizedAt *int64
}

func (q *Queries) InvocationSetFailureIfRunning(ctx context.Context, db DBTX, arg *InvocationSetFailureIfRunningParams) (*InvocationSetFailureIfRunningRow, error) {
	row := db.QueryRow(ctx, invocationSetFailureIfRunning,
		arg.ID,
		arg.FinalizerID,
		arg.FinalizedAt,
		arg.Errors,
	)
	var i InvocationSetFailureIfRunningRow
	err := row.Scan(&i.ID, &i.State, &i.FinalizedAt)
	return &i, err
}
