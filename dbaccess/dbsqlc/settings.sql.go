// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: settings.sql

package dbsqlc

import (
	"context"
)

const settingsGet = `-- name: SettingsGet :one
SELECT key, value FROM settings WHERE key = 'system' LIMIT 1
`

func (q *Queries) SettingsGet(ctx context.Context, db DBTX) (*Settings, error) {
	row := db.QueryRow(ctx, settingsGet)
	var i Settings
	err := row.Scan(&i.Key, &i.Value)
	return &i, err
}

const settingsUpdate = `-- name: SettingsUpdate :one
WITH existing_settings AS (
  SELECT value AS existing_value
  FROM settings
  WHERE key = 'system'
),
merged_settings AS (
  SELECT COALESCE(
    jsonb_object_agg(
      COALESCE(k, key),
      CASE WHEN v IS NOT NULL THEN v ELSE value END
    ),
    '{}'::jsonb
  ) AS merged_value
  FROM jsonb_each(COALESCE((SELECT existing_value FROM existing_settings), '{}'::jsonb)) AS e(key, value)
  FULL OUTER JOIN jsonb_each($1::jsonb) AS n(k, v) ON e.key = n.k
)
INSERT INTO settings (key, value)
VALUES ('system', (SELECT merged_value FROM merged_settings))
ON CONFLICT (key)
DO UPDATE SET value = EXCLUDED.value
RETURNING key, value
`

func (q *Queries) SettingsUpdate(ctx context.Context, db DBTX, value []byte) (*Settings, error) {
	row := db.QueryRow(ctx, settingsUpdate, value)
	var i Settings
	err := row.Scan(&i.Key, &i.Value)
	return &i, err
}
